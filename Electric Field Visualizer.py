"""
Author: Kuba Anglin
Date: 9/30/2024

Massachusetts Institute of Technology
Department of Nuclear Science and Engineering
Plasma Science and Fusion Center

Electric Field Visualization and Computation Tool

Description:
This script computes and visualizes the electric field generated by different configurations of cathode rings.
It allows you to select between 1, 2, 3, or 13 ring configurations and visualize the resulting electric field
cross-sections in both 2D and 3D. You can adjust the plane of the cross-section by changing the angles α (alpha)
and β (beta), as well as the height. The script also provides the option to display electric field lines on the
2D cross-section. Additionally, you can create animated videos sweeping through parameters (Alpha, Beta, or Height),
capture the current cross-section image, and adjust visualization parameters like Gaussian blur and scale coefficients.

Features:
- Compute electric potential and electric field for different cathode configurations (1, 2, 3, or 13 rings).
- Visualize cross-sectional slices of the electric field magnitude in 2D.
- Interactive 3D visualization of the cathode rings and the cross-sectional plane.
- Interactive sliders and buttons to adjust viewing parameters (Alpha, Beta, Height).
- Option to display electric field lines on the 2D plot with adjustable density.
- Load and save computation data for reuse.
- Create animated videos sweeping through parameters with customizable settings.
- Capture the current cross-section image.
- Adjust visualization parameters like Gaussian blur and scale coefficient.
- Simulation summary display.

Dependencies:
- Python 3.x
- NumPy
- CuPy (for GPU acceleration) (optional; the script can be modified to use NumPy only)
- Matplotlib
- SciPy
- tkinter (for file dialogs and GUI elements)
- threading, queue (for video creation progress tracking)

Usage:
- Run the script using a Python interpreter.
- Select a cathode configuration to start the computation.
- Use the sliders and buttons to adjust viewing parameters (Alpha, Beta, Height).
- Toggle the display of electric field lines and adjust their density.
- Adjust the Gaussian blur and scale coefficient for visualization.
- Save or load computation data as needed.
- Use the 'Create Media' button to open settings for creating animated videos.
  - Choose the parameter to sweep (Alpha, Beta, Height), start/end values, increment step, and frame rate.
  - Optionally include field lines in the animation.
  - Capture the current cross-section image.
- View the simulation summary for computation details.

Note:
- The computation can be intensive; ensure that your system meets the requirements.
- The script uses CuPy for GPU acceleration; if a compatible GPU is not available, modifications are needed to use NumPy.
"""

import cupy as cp
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.widgets import Slider, RadioButtons, Button, TextBox
import matplotlib.style as mplstyle
import matplotlib.patches as patches
import matplotlib.colors as colors
from scipy.interpolate import griddata, RegularGridInterpolator
from matplotlib.gridspec import GridSpec, GridSpecFromSubplotSpec
import os
import datetime
import time
import tkinter as tk
from tkinter import ttk
from tkinter import filedialog
import threading
import queue
from scipy.ndimage import gaussian_filter
import warnings
from matplotlib import MatplotlibDeprecationWarning
from matplotlib.figure import Figure
from matplotlib.backends.backend_agg import FigureCanvasAgg as FigureCanvas

# Suppress the specific deprecation warning
warnings.filterwarnings("ignore", category=MatplotlibDeprecationWarning)

mplstyle.use('dark_background')


# ---------------------------
# Parameters and Initialization
# ---------------------------

V0 = -40000
grid_size = 400
grid_resolution = grid_size
cmap = "plasma"

# Define cathode parameters in cm
cathode_radius = 4.572

# Anode parameters in cm
anode_radius = 22.86

# Computation/viewing radius
computation_radius = cathode_radius * 2
view_radius = cathode_radius * 1.5  # For 3D view

# Animation parameters
timer_interval = 50
alpha_step = 5
beta_step = 5
height_step = 0.05

# Initialize variables
V = None
Ex = None
Ey = None
Ez = None
E_magnitude = None
rings = None
X = None
Y = None
Z = None
x = None
y = None
z = None
E_magnitude_norm = None
max_grid_spacing = None
loading_data = False
cathode_radio_cid = None

# Variables for saving computation data
iteration_count_global = None
final_delta_global = None
computation_time_global = None
num_rings = None

# Field lines parameters
field_lines_visible = False
field_line_artist = None
field_line_arrow_patches = []
field_line_density = 2
show_field_line_arrows = False
field_line_width = 1.0

# Initialize computation_in_progress
computation_in_progress = False

# ---------------------------
# Function Definitions
# ---------------------------


def create_ring(n, radius, theta):
    n = n / np.linalg.norm(n)
    if not np.allclose(n, [0, 0, 1]):
        ref = np.array([0, 0, 1])
    else:
        ref = np.array([1, 0, 0])
    u = np.cross(n, ref)
    if np.linalg.norm(u) == 0:
        ref = np.array([1, 0, 0])
        u = np.cross(n, ref)
    u /= np.linalg.norm(u)
    v = np.cross(n, u)
    x = radius * np.cos(theta) * u[0] + radius * np.sin(theta) * v[0]
    y = radius * np.cos(theta) * u[1] + radius * np.sin(theta) * v[1]
    z = radius * np.cos(theta) * u[2] + radius * np.sin(theta) * v[2]
    return x, y, z


def generate_cathode_rings(cathode_radius, num_rings):
    rings = []
    theta = np.linspace(0, 2 * np.pi, 800)
    if num_rings in [1, 2, 3]:
        axes = ['x', 'y', 'z']
        for i in range(num_rings):
            axis = axes[i % 3]
            if axis == 'x':
                n = np.array([1, 0, 0])
            elif axis == 'y':
                n = np.array([0, 1, 0])
            else:
                n = np.array([0, 0, 1])
            x, y, z = create_ring(n, cathode_radius, theta)
            rings.append((x, y, z, n))
    elif num_rings == 13:
        n_horizontal = np.array([0, 0, 1])
        x, y, z = create_ring(n_horizontal, cathode_radius, theta)
        rings.append((x, y, z, n_horizontal))
        vertical_angles = [0, 90, 180, 270]
        for angle in vertical_angles:
            alpha = np.deg2rad(angle)
            n_vertical = np.array([np.cos(alpha), np.sin(alpha), 0])
            x_v, y_v, z_v = create_ring(n_vertical, cathode_radius, theta)
            rings.append((x_v, y_v, z_v, n_vertical))
        phi_rad = np.deg2rad(45)
        for angle in vertical_angles:
            alpha = np.deg2rad(angle)
            n_diag1 = np.array([
                np.cos(alpha) * np.sin(phi_rad),
                np.sin(alpha) * np.sin(phi_rad),
                np.cos(phi_rad)
            ])
            x_d1, y_d1, z_d1 = create_ring(n_diag1, cathode_radius, theta)
            rings.append((x_d1, y_d1, z_d1, n_diag1))
            n_diag2 = np.array([
                np.cos(alpha) * np.sin(phi_rad),
                np.sin(alpha) * np.sin(phi_rad),
                -np.cos(phi_rad)
            ])
            x_d2, y_d2, z_d2 = create_ring(n_diag2, cathode_radius, theta)
            rings.append((x_d2, y_d2, z_d2, n_diag2))
    else:
        raise ValueError("Unsupported number of rings. Choose 1, 2, 3, or 13.")
    return rings


def apply_boundary_conditions(V, rings, V0, x, y, z):
    x = cp.asarray(x, dtype=cp.float64)
    y = cp.asarray(y, dtype=cp.float64)
    z = cp.asarray(z, dtype=cp.float64)
    X, Y, Z = cp.meshgrid(x, y, z, indexing='ij')

    for ring in rings:
        n = ring[3]
        n = cp.asarray(n)
        # Compute the distance from each grid point to the plane of the ring
        d_plane = X * n[0] + Y * n[1] + Z * n[2]
        # Project grid points onto the plane of the ring
        X_proj = X - d_plane * n[0]
        Y_proj = Y - d_plane * n[1]
        Z_proj = Z - d_plane * n[2]
        # Compute radial distance from the center in the plane
        r_in_plane = cp.sqrt(X_proj**2 + Y_proj**2 + Z_proj**2)
        # Create mask for points that lie on the ring surface
        tolerance = max_grid_spacing * 0.5
        mask = (cp.abs(d_plane) < tolerance) & (cp.abs(r_in_plane - cathode_radius) < tolerance)
        V[mask] = V0

    # Apply anode boundary conditions
    distance_squared = X**2 + Y**2 + Z**2
    anode_mask = distance_squared >= anode_radius**2
    V[anode_mask] = 0
    return V


def solve_potential(V, rings, V0, x, y, z, max_iter=1e6, tolerance=1e-4):
    start_time = time.time()
    V = cp.asarray(V, dtype=cp.float64)
    x = cp.asarray(x, dtype=cp.float64)
    y = cp.asarray(y, dtype=cp.float64)
    z = cp.asarray(z, dtype=cp.float64)
    delta = None
    for iteration in range(int(max_iter) + 1):
        V_old = V.copy()
        V[1:-1, 1:-1, 1:-1] = (1.0 / 6.0) * (
            V[:-2, 1:-1, 1:-1] + V[2:, 1:-1, 1:-1] +
            V[1:-1, :-2, 1:-1] + V[1:-1, 2:, 1:-1] +
            V[1:-1, 1:-1, :-2] + V[1:-1, 1:-1, 2:]
        )
        # Apply boundary conditions
        V = apply_boundary_conditions(V, rings, V0, x, y, z)
        delta = cp.max(cp.abs(V - V_old))
        if delta < tolerance:
            print(f"Converged after {iteration} iterations with delta={delta}")
            break
        if iteration % 100 == 0:
            print(f"Iteration {iteration}, delta={delta}")
    else:
        print("Did not converge within the maximum number of iterations.")
    end_time = time.time()
    computation_time = end_time - start_time
    V_cpu = cp.asnumpy(V)
    delta_cpu = delta.get().item()
    return V_cpu, iteration, delta_cpu, computation_time


def scale_E_field(E_magnitude, scaling):
    E_min = E_magnitude.min()
    E_max = E_magnitude.max()
    E_scaled = (E_magnitude - E_min) / (E_max - E_min)
    return E_scaled


def get_plane_basis_vectors(n, alpha_rad):
    # Initial v1 in x-y plane
    v1 = np.array([-np.sin(alpha_rad), np.cos(alpha_rad), 0.0])
    # Adjust v1 to be orthogonal to n
    v1 = v1 - n * np.dot(n, v1)
    v1 /= np.linalg.norm(v1)
    # Compute v2 as cross product of n and v1
    v2 = np.cross(n, v1)
    return v1, v2


def get_slice(E_magnitude_norm, X, Y, Z, alpha, beta, height, max_grid_spacing, Ex, Ey, Ez, x, y, z):
    alpha_rad = np.deg2rad(alpha)
    beta_rad = np.deg2rad(beta)
    n = np.array([
        np.sin(beta_rad) * np.cos(alpha_rad),
        np.sin(beta_rad) * np.sin(alpha_rad),
        np.cos(beta_rad)
    ])
    p0 = np.array([0, 0, height])
    X_flat = X.flatten()
    Y_flat = Y.flatten()
    Z_flat = Z.flatten()
    E_flat = E_magnitude_norm.flatten()
    points = np.vstack((X_flat, Y_flat, Z_flat)).T
    distances = np.dot(points - p0, n)
    thickness = max_grid_spacing * 1.5
    mask = np.abs(distances) < (thickness / 2)
    points_on_plane = points[mask] - np.outer(distances[mask], n)
    E_plane = E_flat[mask]
    if points_on_plane.size == 0:
        return np.array([]), np.array([]), np.array([]), np.array([]), np.array([])
    # Compute basis vectors for the plane
    v1, v2 = get_plane_basis_vectors(n, alpha_rad)
    # Ensure points are within the interpolation domain
    x_min, x_max = x[0], x[-1]
    y_min, y_max = y[0], y[-1]
    z_min, z_max = z[0], z[-1]  # Corrected here
    # Filter out-of-bounds points
    in_bounds_mask = (
        (points_on_plane[:, 0] >= x_min) & (points_on_plane[:, 0] <= x_max) &
        (points_on_plane[:, 1] >= y_min) & (points_on_plane[:, 1] <= y_max) &
        (points_on_plane[:, 2] >= z_min) & (points_on_plane[:, 2] <= z_max)
    )
    points_on_plane = points_on_plane[in_bounds_mask]
    E_plane = E_plane[in_bounds_mask]
    if points_on_plane.size == 0:
        return np.array([]), np.array([]), np.array([]), np.array([]), np.array([])
    u = np.dot(points_on_plane - p0, v1)
    v_coord = np.dot(points_on_plane - p0, v2)
    # Ensure arrays are NumPy arrays
    if isinstance(x, cp.ndarray):
        x_cpu = cp.asnumpy(x)
    else:
        x_cpu = x
    if isinstance(y, cp.ndarray):
        y_cpu = cp.asnumpy(y)
    else:
        y_cpu = y
    if isinstance(z, cp.ndarray):
        z_cpu = cp.asnumpy(z)
    else:
        z_cpu = z
    if isinstance(Ex, cp.ndarray):
        Ex_cpu = cp.asnumpy(Ex)
    else:
        Ex_cpu = Ex
    if isinstance(Ey, cp.ndarray):
        Ey_cpu = cp.asnumpy(Ey)
    else:
        Ey_cpu = Ey
    if isinstance(Ez, cp.ndarray):
        Ez_cpu = cp.asnumpy(Ez)
    else:
        Ez_cpu = Ez
    points_on_plane_cpu = points_on_plane  # Already a NumPy array
    # Interpolate Ex, Ey, Ez at points_on_plane
    Ex_interp = RegularGridInterpolator((x_cpu, y_cpu, z_cpu), Ex_cpu, bounds_error=False, fill_value=0.0)
    Ey_interp = RegularGridInterpolator((x_cpu, y_cpu, z_cpu), Ey_cpu, bounds_error=False, fill_value=0.0)
    Ez_interp = RegularGridInterpolator((x_cpu, y_cpu, z_cpu), Ez_cpu, bounds_error=False, fill_value=0.0)
    E_points = np.vstack((
        Ex_interp(points_on_plane_cpu),
        Ey_interp(points_on_plane_cpu),
        Ez_interp(points_on_plane_cpu)
    )).T
    # Compute components in plane
    E_u = np.dot(E_points, v1)
    E_v = np.dot(E_points, v2)
    return u, v_coord, E_plane, E_u, E_v


def set_axes_equal(ax):
    x_limits = ax.get_xlim3d()
    y_limits = ax.get_ylim3d()
    z_limits = ax.get_zlim3d()
    x_range = abs(x_limits[1] - x_limits[0])
    x_middle = np.mean(x_limits)
    y_range = abs(y_limits[1] - y_limits[0])
    y_middle = np.mean(y_limits)
    z_range = abs(z_limits[1] - z_limits[0])
    z_middle = np.mean(z_limits)
    plot_radius = 0.5 * max([x_range, y_range, z_range])
    ax.set_xlim3d([x_middle - plot_radius, x_middle + plot_radius])
    ax.set_ylim3d([y_middle - plot_radius, y_middle + plot_radius])
    ax.set_zlim3d([z_middle - plot_radius, z_middle + plot_radius])


def plot_cross_section_plane(ax, alpha, beta, height):
    global current_plane
    if current_plane is not None:
        current_plane.remove()
    alpha_rad = np.deg2rad(alpha)
    beta_rad = np.deg2rad(beta)
    n = np.array([
        np.sin(beta_rad) * np.cos(alpha_rad),
        np.sin(beta_rad) * np.sin(alpha_rad),
        np.cos(beta_rad)
    ])
    plane_size = cathode_radius * 1.4
    u = np.linspace(-plane_size, plane_size, 10)
    v = np.linspace(-plane_size, plane_size, 10)
    U, V_grid = np.meshgrid(u, v)
    p0 = np.array([0, 0, height])
    # Compute basis vectors for the plane
    v1, v2 = get_plane_basis_vectors(n, alpha_rad)
    # Compute the plane coordinates
    X_plane = p0[0] + U * v1[0] + V_grid * v2[0]
    Y_plane = p0[1] + U * v1[1] + V_grid * v2[1]
    Z_plane = p0[2] + U * v1[2] + V_grid * v2[2]
    current_plane = ax.plot_surface(X_plane, Y_plane, Z_plane, color='purple', alpha=0.2)

# ---------------------------
# Plot Initialization
# ---------------------------


initial_alpha = 0
initial_beta = 0
initial_height = 0.0
fig = plt.figure(figsize=(18, 10))
gs = GridSpec(2, 3, figure=fig, width_ratios=[3, 1, 1], height_ratios=[4, 1])
plt.subplots_adjust(left=0.05, bottom=0.05, right=0.95, top=0.95, wspace=0.3, hspace=0.4)

ax_2d = fig.add_subplot(gs[0, 0])

# Placeholder image
placeholder_image = np.zeros((grid_size, grid_size))
im = ax_2d.imshow(
    placeholder_image,
    extent=(-computation_radius, computation_radius, -computation_radius, computation_radius),
    origin='lower',
    cmap=cmap,
    aspect='equal',
    norm=colors.PowerNorm(gamma=1.0)
)
ax_2d.set_xlim(-computation_radius, computation_radius)
ax_2d.set_ylim(-computation_radius, computation_radius)
ax_2d.set_aspect('equal', 'box')
ax_2d.set_xlabel('u (cm)')
ax_2d.set_ylabel('v (cm)')
ax_2d.set_title('Select cathode configuration to start computation or load previous data')
cbar = fig.colorbar(im, ax=ax_2d, fraction=0.046, pad=0.04)
cbar.set_label('Normalized Electric Field Strength', color='white', fontsize=12)
cbar.ax.yaxis.set_tick_params(color='white')
plt.setp(cbar.ax.axes, facecolor='#303030')
cbar.ax.yaxis.label.set_color('white')

# Create bottom_gs in gs[1, 0]
bottom_gs = GridSpecFromSubplotSpec(1, 1, subplot_spec=gs[1, 0], wspace=0.3)
ax_summary = fig.add_subplot(bottom_gs[0, 0])

# Configure ax_summary
ax_summary.set_facecolor('#404040')
ax_summary.tick_params(left=False, bottom=False, labelleft=False, labelbottom=False)
for spine in ax_summary.spines.values():
    spine.set_visible(True)
    spine.set_color('white')
ax_summary.set_title('Simulation Summary', color='white', fontsize=12)

# Adjust the position and width of ax_summary to make it less wide
pos = ax_summary.get_position()
ax_summary.set_position([pos.x0 + pos.width * 0.25, pos.y0, pos.width * 0.5, pos.height])

# Initialize summary text with "Simulation not yet performed."
summary_text = ax_summary.text(
    0.05, 0.95, 'Simulation not yet performed or loaded', ha='left', va='top',
    transform=ax_summary.transAxes, wrap=True, fontsize=12, color='white', fontfamily='monospace'
)

# ---------------------------
# Add Widgets
# ---------------------------

# Adjust the control grid to accommodate the new button
control_gs = GridSpecFromSubplotSpec(8, 1, subplot_spec=gs[:, 1:], hspace=0.5, height_ratios=[1,1,1,1,1,1,1,2])

ax_cathode_config = fig.add_subplot(control_gs[0, 0])
ax_cathode_config.set_facecolor('#404040')
cathode_radio = RadioButtons(ax_cathode_config, ['Select Configuration', '1 Ring', '2 Rings', '3 Rings', '13 Rings'], active=0)
for label in cathode_radio.labels:
    label.set_color('white')
ax_cathode_config.set_title('Cathode Configuration', color='white', fontsize=12)

ax_interpolation = fig.add_subplot(control_gs[1, 0])
ax_interpolation.set_facecolor('#404040')
interpolation_radio = RadioButtons(ax_interpolation, ['Nearest', 'Linear', 'Cubic'], active=0)
for label in interpolation_radio.labels:
    label.set_color('white')
ax_interpolation.set_title('Interpolation Mode', color='white', fontsize=12)

ax_load_button = fig.add_subplot(control_gs[2, 0])
ax_load_button.set_facecolor('#404040')
load_button = Button(ax_load_button, 'Load Computation Data', color='#404040', hovercolor='#505050')
load_button.label.set_color('white')

ax_save_button = fig.add_subplot(control_gs[3, 0])
ax_save_button.set_facecolor('#404040')
save_button = Button(ax_save_button, 'Save Computation Data', color='#404040', hovercolor='#505050')
save_button.label.set_color('white')

ax_fieldline_button = fig.add_subplot(control_gs[4, 0])
ax_fieldline_button.set_facecolor('#404040')
fieldline_button = Button(ax_fieldline_button, 'Show Field Lines', color='#404040', hovercolor='#505050')
fieldline_button.label.set_color('white')

# Add the GIF creation button
ax_gif_button = fig.add_subplot(control_gs[5, 0])
ax_gif_button.set_facecolor('#404040')
gif_button = Button(ax_gif_button, 'Create Media', color='#404040', hovercolor='#505050')
gif_button.label.set_color('white')

# Adjust positions if necessary
for ax in [ax_cathode_config, ax_interpolation, ax_load_button, ax_save_button, ax_fieldline_button, ax_gif_button]:
    box = ax.get_position()
    ax.set_position([box.x0, box.y0, box.width * 0.8, box.height])

for ax in [ax_cathode_config, ax_interpolation, ax_load_button, ax_save_button, ax_fieldline_button]:
    box = ax.get_position()
    ax.set_position([box.x0, box.y0, box.width * 0.8, box.height])

sliders_gs = GridSpecFromSubplotSpec(6, 6, subplot_spec=control_gs[6, 0], hspace=0.4, wspace=0.3)

# Field Line Density Slider
ax_field_density = fig.add_subplot(sliders_gs[4, :2])
ax_field_density.set_facecolor('#505050')
slider_field_density = Slider(
    ax_field_density, 'Field Line Density  ', 0.1, 6,
    valinit=field_line_density, valstep=0.1, color='#ffffff'
)
slider_field_density.valtext.set_visible(False)

# Field Line Density Text Box
ax_field_density_text = fig.add_subplot(sliders_gs[4, 2])
ax_field_density_text.set_facecolor('#505050')
text_field_density = TextBox(
    ax_field_density_text, '', initial=f"{field_line_density:.1f}",
    color='#404040', hovercolor='#505050'
)
text_field_density.label.set_color('white')
text_field_density.text_disp.set_color('white')

# Field Line Density Decrement Button
button_field_density_dec_ax = fig.add_subplot(sliders_gs[4, 3], aspect='auto')
button_field_density_dec = Button(
    button_field_density_dec_ax, '-', color='#404040', hovercolor='#505050'
)
button_field_density_dec.label.set_color('white')

# Field Line Density Increment Button
button_field_density_inc_ax = fig.add_subplot(sliders_gs[4, 4], aspect='auto')
button_field_density_inc = Button(
    button_field_density_inc_ax, '+', color='#404040', hovercolor='#505050'
)
button_field_density_inc.label.set_color('white')

# Gaussian Blur Slider with Text Box and Buttons
ax_gaussian_blur = fig.add_subplot(sliders_gs[5, :2])
ax_gaussian_blur.set_facecolor('#505050')
slider_gaussian_blur = Slider(
    ax_gaussian_blur, 'Gaussian Blur  ', 0.0, 1.0,
    valinit=0.10, valstep=0.01, color='#ffffff'
)
slider_gaussian_blur.valtext.set_visible(False)

# Gaussian Blur Text Box
ax_gaussian_blur_text = fig.add_subplot(sliders_gs[5, 2])
ax_gaussian_blur_text.set_facecolor('#505050')
text_gaussian_blur = TextBox(
    ax_gaussian_blur_text, '', initial=f"{slider_gaussian_blur.val:.2f}",
    color='#404040', hovercolor='#505050'
)
text_gaussian_blur.label.set_color('white')
text_gaussian_blur.text_disp.set_color('white')

# Gaussian Blur Decrement Button
button_gaussian_blur_dec_ax = fig.add_subplot(sliders_gs[5, 3], aspect='auto')
button_gaussian_blur_dec = Button(
    button_gaussian_blur_dec_ax, '-', color='#404040', hovercolor='#505050'
)
button_gaussian_blur_dec.label.set_color('white')

# Gaussian Blur Increment Button
button_gaussian_blur_inc_ax = fig.add_subplot(sliders_gs[5, 4], aspect='auto')
button_gaussian_blur_inc = Button(
    button_gaussian_blur_inc_ax, '+', color='#404040', hovercolor='#505050'
)
button_gaussian_blur_inc.label.set_color('white')


def create_animated_video(parameter, start_value, end_value, step, frame_rate,
                          include_field_lines, blur_amount, scale_coef, field_line_density,
                          video_window):
    global field_lines_visible, E_magnitude_norm, X, Y, Z, Ex, Ey, Ez, x, y, z, max_grid_spacing
    if step == 0:
        print("Step value cannot be zero.")
        return

    # Create a queue reference
    progress_queue = video_window.progress_queue

    # Generate the range of values
    values = np.arange(start_value, end_value + step, step)
    total_frames = len(values)

    # Store the original values to restore later
    original_alpha = slider_alpha.val
    original_beta = slider_beta.val
    original_height = slider_height.val
    original_field_lines_visible = field_lines_visible

    # Create a new figure for the animation without interfering with the main GUI
    anim_fig = Figure(figsize=(8, 8), dpi=200, facecolor='white')
    anim_ax = anim_fig.add_subplot(111)
    anim_ax.set_axis_off()
    anim_ax.set_facecolor('white')
    anim_ax.set_position([0, 0, 1, 1])

    # Create a canvas
    canvas = FigureCanvas(anim_fig)

    # Define the video filenames with timestamp
    timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
    base_filename = f"animated_{parameter.lower()}_{timestamp}"
    video_filename_without_field_lines = f"{base_filename}_without_field_lines.mp4"

    # Use FFMpegWriter for saving the animation
    from matplotlib.animation import FFMpegWriter

    # Prepare the writers
    metadata = dict(title='Electric Field Animation', artist='Kuba Anglin', comment='Electric Field Visualization')
    writer_without_field_lines = FFMpegWriter(fps=frame_rate, metadata=metadata)

    # Check if field lines are included
    if include_field_lines:
        video_filename_with_field_lines = f"{base_filename}_with_field_lines.mp4"
        writer_with_field_lines = FFMpegWriter(fps=frame_rate, metadata=metadata)
    else:
        writer_with_field_lines = None

    # Initialize variables for time estimation
    frame_times = []
    start_time = time.time()

    # Use the image array's shape to determine the number of grid points
    num_grid_points = 400  # Adjust as needed
    cross_section_radius = cathode_radius * 2
    ui_fixed = np.linspace(-cross_section_radius, cross_section_radius, num_grid_points)
    vi_fixed = np.linspace(-cross_section_radius, cross_section_radius, num_grid_points)
    ui_grid_fixed, vi_grid_fixed = np.meshgrid(ui_fixed, vi_fixed)

    interpolation = interpolation_radio.value_selected.lower()  # Get interpolation from user selection

    # Prepare for field lines if needed
    arrowsize_value = 1
    field_line_width = 0.5

    # Open the writers
    writer_without_field_lines_setup = writer_without_field_lines.saving(anim_fig, video_filename_without_field_lines, dpi=200)
    if include_field_lines:
        writer_with_field_lines_setup = writer_with_field_lines.saving(anim_fig, video_filename_with_field_lines, dpi=200)

    # Use context managers to handle the writers
    if include_field_lines:
        with writer_without_field_lines_setup, writer_with_field_lines_setup:
            for idx, val in enumerate(values):
                frame_start_time = time.time()

                # Initialize alpha, beta, height to original values
                alpha = original_alpha
                beta = original_beta
                height = original_height

                # Update the parameter being swept
                if parameter == 'Alpha':
                    alpha = val
                elif parameter == 'Beta':
                    beta = val
                elif parameter == 'Height':
                    height = val
                else:
                    print("Invalid parameter selected.")
                    return

                print(f"Creating frame {idx+1}/{total_frames}: alpha={alpha}, beta={beta}, height={height}")

                # Compute the frame data once
                Ei, E_u_interp, E_v_interp = compute_frame_data_for_animation(
                    alpha, beta, height, ui_grid_fixed, vi_grid_fixed, interpolation, blur_amount
                )

                # --- Create Frame Without Field Lines ---
                anim_ax.clear()
                anim_ax.set_axis_off()
                anim_ax.set_facecolor('white')
                anim_ax.set_position([0, 0, 1, 1])

                # Plot the image
                anim_ax.imshow(
                    Ei.T,
                    extent=(-cross_section_radius, cross_section_radius, -cross_section_radius, cross_section_radius),
                    origin='lower',
                    cmap=cmap,
                    aspect='equal',
                    norm=colors.PowerNorm(gamma=scale_coef)
                )
                anim_ax.set_xlim(-cross_section_radius, cross_section_radius)
                anim_ax.set_ylim(-cross_section_radius, cross_section_radius)

                # Draw the current frame without field lines
                canvas.draw()
                writer_without_field_lines.grab_frame()

                # --- Create Frame With Field Lines ---
                if E_u_interp is not None and E_v_interp is not None:
                    # Overlay field lines
                    anim_ax.streamplot(
                        ui_fixed, vi_fixed,
                        E_u_interp.T, E_v_interp.T,
                        color='white', linewidth=field_line_width,
                        density=field_line_density,
                        arrowsize=arrowsize_value
                    )

                    # Remove arrowheads if not desired
                    for art in anim_ax.get_children():
                        if isinstance(art, patches.FancyArrowPatch):
                            art.remove()

                    # Draw the current frame with field lines
                    canvas.draw()
                    writer_with_field_lines.grab_frame()
                else:
                    # If field lines cannot be computed, write the same frame
                    writer_with_field_lines.grab_frame()

                # Calculate time taken for this frame
                frame_end_time = time.time()
                frame_time = frame_end_time - frame_start_time
                frame_times.append(frame_time)

                # Calculate average time per frame
                avg_time_per_frame = np.mean(frame_times)

                # Estimate total time and time remaining
                estimated_total_time = avg_time_per_frame * total_frames
                elapsed_time = frame_end_time - start_time
                time_remaining = estimated_total_time - elapsed_time

                # Format time remaining
                time_remaining_str = time.strftime("%H:%M:%S", time.gmtime(max(0, time_remaining)))

                # Update progress
                progress = ((idx + 1) / total_frames) * 100

                # Put progress info into the queue
                progress_info = {
                    'progress': progress,
                    'time_remaining': time_remaining_str,
                    'frame_counter': f'Frame {idx+1}/{total_frames}'
                }
                progress_queue.put(progress_info)

    else:
        with writer_without_field_lines_setup:
            for idx, val in enumerate(values):
                frame_start_time = time.time()

                # Initialize alpha, beta, height to original values
                alpha = original_alpha
                beta = original_beta
                height = original_height

                # Update the parameter being swept
                if parameter == 'Alpha':
                    alpha = val
                elif parameter == 'Beta':
                    beta = val
                elif parameter == 'Height':
                    height = val
                else:
                    print("Invalid parameter selected.")
                    return

                print(f"Creating frame {idx+1}/{total_frames}: alpha={alpha}, beta={beta}, height={height}")

                # Compute the frame data once
                Ei, E_u_interp, E_v_interp = compute_frame_data_for_animation(
                    alpha, beta, height, ui_grid_fixed, vi_grid_fixed, interpolation, blur_amount
                )

                # --- Create Frame Without Field Lines ---
                anim_ax.clear()
                anim_ax.set_axis_off()
                anim_ax.set_facecolor('white')
                anim_ax.set_position([0, 0, 1, 1])

                # Plot the image
                anim_ax.imshow(
                    Ei.T,
                    extent=(-cross_section_radius, cross_section_radius, -cross_section_radius, cross_section_radius),
                    origin='lower',
                    cmap=cmap,
                    aspect='equal',
                    norm=colors.PowerNorm(gamma=scale_coef)
                )
                anim_ax.set_xlim(-cross_section_radius, cross_section_radius)
                anim_ax.set_ylim(-cross_section_radius, cross_section_radius)

                # Draw the current frame without field lines
                canvas.draw()
                writer_without_field_lines.grab_frame()

                # Calculate time taken for this frame
                frame_end_time = time.time()
                frame_time = frame_end_time - frame_start_time
                frame_times.append(frame_time)

                # Calculate average time per frame
                avg_time_per_frame = np.mean(frame_times)

                # Estimate total time and time remaining
                estimated_total_time = avg_time_per_frame * total_frames
                elapsed_time = frame_end_time - start_time
                time_remaining = estimated_total_time - elapsed_time

                # Format time remaining
                time_remaining_str = time.strftime("%H:%M:%S", time.gmtime(max(0, time_remaining)))

                # Update progress
                progress = ((idx + 1) / total_frames) * 100

                # Put progress info into the queue
                progress_info = {
                    'progress': progress,
                    'time_remaining': time_remaining_str,
                    'frame_counter': f'Frame {idx+1}/{total_frames}'
                }
                progress_queue.put(progress_info)

    # After video creation is complete, send completion message
    progress_queue.put({'progress': 100, 'time_remaining': 'Video creation complete!', 'frame_counter': ''})

    # Restore original values
    slider_alpha.set_val(original_alpha)
    text_alpha.set_val(f"{original_alpha:.2f}")
    slider_beta.set_val(original_beta)
    text_beta.set_val(f"{original_beta:.2f}")
    slider_height.set_val(original_height)
    text_height.set_val(f"{original_height:.2f}")
    field_lines_visible = original_field_lines_visible
    update_plot(None)

    if include_field_lines:
        print(f"Videos saved as {video_filename_without_field_lines} and {video_filename_with_field_lines}")
    else:
        print(f"Video saved as {video_filename_without_field_lines}")


def compute_frame_data_for_animation(alpha, beta, height, ui_grid_fixed, vi_grid_fixed,
                                     interpolation, blur_amount):
    global E_magnitude_norm, X, Y, Z, Ex, Ey, Ez, x, y, z, max_grid_spacing
    u_new, v_new, E_plane_new, E_u, E_v = get_slice(
        E_magnitude_norm, X, Y, Z, alpha, beta, height, max_grid_spacing, Ex, Ey, Ez, x, y, z
    )
    if len(u_new) == 0 or len(v_new) == 0:
        print(f"No data points found for the slice at alpha={alpha}, beta={beta}, height={height}")
        Ei = np.zeros_like(ui_grid_fixed)
        E_u_interp = None
        E_v_interp = None
    else:
        # Interpolate onto the grid
        Ei = griddata((u_new, v_new), E_plane_new, (ui_grid_fixed, vi_grid_fixed), method=interpolation)
        Ei = np.nan_to_num(Ei, nan=0.0)

        # Interpolate field components
        E_u_interp = griddata((u_new, v_new), E_u, (ui_grid_fixed, vi_grid_fixed), method=interpolation)
        E_v_interp = griddata((u_new, v_new), E_v, (ui_grid_fixed, vi_grid_fixed), method=interpolation)
        E_u_interp = np.nan_to_num(E_u_interp, nan=0.0)
        E_v_interp = np.nan_to_num(E_v_interp, nan=0.0)

    # Apply Gaussian blur if needed
    if blur_amount > 0:
        max_sigma = 5  # Adjust this value as needed for maximum blur
        sigma = blur_amount * max_sigma
        Ei_blurred = gaussian_filter(Ei, sigma=sigma)
    else:
        Ei_blurred = Ei

    return Ei_blurred, E_u_interp, E_v_interp

def open_video_settings(event):
    # Create a new window
    video_window = tk.Toplevel()
    video_window.title("Animated Video Settings")

    # Define variables for user inputs
    sweep_var = tk.StringVar(value='Beta')
    include_field_lines_var = tk.BooleanVar(value=field_lines_visible)
    start_var = tk.DoubleVar(value=1)
    end_var = tk.DoubleVar(value=180)
    step_var = tk.DoubleVar(value=0.2)
    frame_rate_var = tk.DoubleVar(value=60)

    # Add widgets to the window
    tk.Label(video_window, text="Select Parameter to Sweep:").grid(row=0, column=0, sticky='w')
    sweep_options = ['Alpha', 'Beta', 'Height']
    sweep_menu = tk.OptionMenu(video_window, sweep_var, *sweep_options)
    sweep_menu.grid(row=0, column=1, sticky='w')

    tk.Label(video_window, text="Start Value:").grid(row=1, column=0, sticky='w')
    tk.Entry(video_window, textvariable=start_var).grid(row=1, column=1, sticky='w')

    tk.Label(video_window, text="End Value:").grid(row=2, column=0, sticky='w')
    tk.Entry(video_window, textvariable=end_var).grid(row=2, column=1, sticky='w')

    tk.Label(video_window, text="Increment Step:").grid(row=3, column=0, sticky='w')
    tk.Entry(video_window, textvariable=step_var).grid(row=3, column=1, sticky='w')

    tk.Label(video_window, text="Frame Rate (fps):").grid(row=4, column=0, sticky='w')
    tk.Entry(video_window, textvariable=frame_rate_var).grid(row=4, column=1, sticky='w')

    tk.Checkbutton(video_window, text="Include Field Lines", variable=include_field_lines_var).grid(row=5, column=0, columnspan=2, sticky='w')

    # Add Capture Cross-Section button
    def capture_current_cross_section():
        global field_line_density, field_line_width  # Ensure these variables are accessible

        # Create a new figure with higher resolution
        cross_section_fig = Figure(figsize=(8, 8), dpi=300, facecolor='white')
        cross_section_ax = cross_section_fig.add_subplot(111)
        cross_section_ax.set_axis_off()
        cross_section_ax.set_facecolor('white')
        cross_section_ax.set_position([0, 0, 1, 1])  # Adjust axis position to fill the figure

        # Copy the image data without axes or labels
        cross_section_ax.imshow(
            im.get_array(),
            extent=im.get_extent(),
            origin='lower',
            cmap=cmap,
            aspect='equal',
            norm=im.norm
        )
        cross_section_ax.set_xlim(ax_2d.get_xlim())
        cross_section_ax.set_ylim(ax_2d.get_ylim())

        # Plot field lines if they are visible
        if field_lines_visible and field_line_artist is not None:
            # Ensure necessary variables are accessible
            if hasattr(update_plot, 'ui_fixed') and hasattr(update_plot, 'vi_fixed') and \
                    hasattr(update_plot, 'E_u_interp') and hasattr(update_plot, 'E_v_interp'):
                # Plot field lines
                cross_section_ax.streamplot(
                    update_plot.ui_fixed, update_plot.vi_fixed,
                    update_plot.E_u_interp.T, update_plot.E_v_interp.T,
                    color='white', linewidth=field_line_width,
                    density=field_line_density,
                    arrowsize=1
                )

                # Remove arrowheads if not desired
                for art in cross_section_ax.get_children():
                    if isinstance(art, patches.FancyArrowPatch):
                        art.remove()

        # Open a file dialog to choose the save location
        file_path = filedialog.asksaveasfilename(
            title='Save Cross-Section Image',
            defaultextension='.png',
            filetypes=[('PNG files', '*.png'), ('All files', '*.*')]
        )
        if file_path:
            # Save the cross-section figure without margins
            cross_section_fig.savefig(file_path, dpi=300, bbox_inches='tight', pad_inches=0)
            print(f"Cross-section image saved to {file_path}")
        plt.close(cross_section_fig)

    tk.Button(video_window, text="Capture Cross-Section", command=capture_current_cross_section).grid(row=6, column=0, columnspan=2)

    # Add Progress Bar
    progress_var = tk.DoubleVar()
    video_window.progress_var = progress_var  # Attach progress_var to video_window
    progress_bar = ttk.Progressbar(video_window, variable=progress_var, maximum=100)
    progress_bar.grid(row=8, column=0, columnspan=2, sticky='we')

    # Add Estimated Time Remaining Label
    time_remaining_var = tk.StringVar()
    video_window.time_remaining_var = time_remaining_var  # Attach to video_window
    time_remaining_label = tk.Label(video_window, textvariable=time_remaining_var)
    time_remaining_label.grid(row=9, column=0, columnspan=2, sticky='we')

    # Initialize the estimated time remaining
    video_window.time_remaining_var.set("Estimated Time Remaining: Calculating...")
    video_window.is_closing = False

    # Define the function to update the progress bar
    def update_progress_bar():
        try:
            progress_info = video_window.progress_queue.get_nowait()
            if video_window.winfo_exists():
                # Update the progress bar and label
                progress = progress_info.get('progress', 0)
                time_remaining = progress_info.get('time_remaining', '')
                frame_counter = progress_info.get('frame_counter', '')

                video_window.progress_var.set(progress)
                video_window.time_remaining_var.set(f"Estimated Time Remaining: {time_remaining} {frame_counter}")
                video_window.update_idletasks()

                # Check if video creation is complete
                if progress >= 100:
                    # Close the video window after a short delay
                    video_window.is_closing = True  # Set the closing flag
                    video_window.after(1000, video_window.destroy)
                    return  # Stop the update loop
        except queue.Empty:
            pass
        except tk.TclError:
            # The window has been closed; stop the loop
            return
        except Exception as e:
            print(f"Error updating progress bar: {e}")
            return
        finally:
            # Schedule the next check if the window still exists and is not closing
            if not video_window.is_closing and video_window.winfo_exists():
                video_window.after_id = video_window.after(100, update_progress_bar)

    # Fetch necessary values from GUI elements
    blur_amount = slider_gaussian_blur.val
    scale_coef = slider_scale_coef.val
    field_line_density = slider_field_density.val

    # Start video creation button
    def start_video_creation():
        # Create a queue for communication
        progress_queue = queue.Queue()
        video_window.progress_queue = progress_queue

        # Start the GUI update loop
        update_progress_bar()

        # Start the video creation in a separate thread
        video_creation_thread = threading.Thread(
            target=create_animated_video,
            args=(
                sweep_var.get(),
                start_var.get(),
                end_var.get(),
                step_var.get(),
                frame_rate_var.get(),
                include_field_lines_var.get(),
                blur_amount,
                scale_coef,
                field_line_density,
                video_window
            ),
            daemon=True
        )
        video_creation_thread.start()

    tk.Button(video_window, text="Create Video", command=start_video_creation).grid(row=7, column=0, columnspan=2)

    # Start the GUI update loop
    # update_progress_bar()

    # Add protocol handler for window close event
    def on_window_close():
        video_window.is_closing = True  # Set the closing flag
        # Cancel any pending callbacks
        if hasattr(video_window, 'after_id'):
            video_window.after_cancel(video_window.after_id)
        video_window.destroy()

    video_window.protocol("WM_DELETE_WINDOW", on_window_close)


# Bind the button to the function
gif_button.on_clicked(open_video_settings)


# Update functions
def update_field_density(val):
    text_field_density.set_val(f"{slider_field_density.val:.1f}")
    update_plot(val)


def submit_field_density(text):
    try:
        value = float(text)
        if slider_field_density.valmin <= value <= slider_field_density.valmax:
            slider_field_density.set_val(value)
        else:
            print(f"Field line density must be between {slider_field_density.valmin} and {slider_field_density.valmax}")
    except ValueError:
        print("Invalid input for field line density")


slider_field_density.on_changed(update_field_density)
text_field_density.on_submit(submit_field_density)


def decrement_field_density(event):
    new_val = slider_field_density.val - slider_field_density.valstep
    if new_val >= slider_field_density.valmin:
        slider_field_density.set_val(new_val)
    else:
        slider_field_density.set_val(slider_field_density.valmin)
    text_field_density.set_val(f"{slider_field_density.val:.1f}")


def increment_field_density(event):
    new_val = slider_field_density.val + slider_field_density.valstep
    if new_val <= slider_field_density.valmax:
        slider_field_density.set_val(new_val)
    else:
        slider_field_density.set_val(slider_field_density.valmax)
    text_field_density.set_val(f"{slider_field_density.val:.1f}")


button_field_density_dec.on_clicked(decrement_field_density)
button_field_density_inc.on_clicked(increment_field_density)

ax_alpha = fig.add_subplot(sliders_gs[0, :2])
ax_alpha.set_facecolor('#505050')
slider_alpha = Slider(ax_alpha, 'α (°)  ', 0, 360, valinit=initial_alpha, valstep=5, color='#ffffff')
slider_alpha.valtext.set_visible(False)

ax_alpha_text = fig.add_subplot(sliders_gs[0, 2])
ax_alpha_text.set_facecolor('#505050')
text_alpha = TextBox(ax_alpha_text, '', initial=str(initial_alpha), color='#404040', hovercolor='#505050')
text_alpha.label.set_color('white')
text_alpha.text_disp.set_color('white')

button_alpha_dec_ax = fig.add_subplot(sliders_gs[0, 3], aspect='auto')
button_alpha_dec = Button(button_alpha_dec_ax, '-', color='#404040', hovercolor='#505050')
button_alpha_dec.label.set_color('white')

button_alpha_inc_ax = fig.add_subplot(sliders_gs[0, 4], aspect='auto')
button_alpha_inc = Button(button_alpha_inc_ax, '+', color='#404040', hovercolor='#505050')
button_alpha_inc.label.set_color('white')

button_alpha_ax = fig.add_subplot(sliders_gs[0, 5])
button_alpha = Button(button_alpha_ax, 'Start α', color='#404040', hovercolor='#505050')
button_alpha.label.set_color('white')

ax_beta = fig.add_subplot(sliders_gs[1, :2])
ax_beta.set_facecolor('#505050')
slider_beta = Slider(ax_beta, 'β (°)  ', 0, 180, valinit=initial_beta, valstep=5, color='#ffffff')
slider_beta.valtext.set_visible(False)

ax_beta_text = fig.add_subplot(sliders_gs[1, 2])
ax_beta_text.set_facecolor('#505050')
text_beta = TextBox(ax_beta_text, '', initial=str(initial_beta), color='#404040', hovercolor='#505050')
text_beta.label.set_color('white')
text_beta.text_disp.set_color('white')

button_beta_dec_ax = fig.add_subplot(sliders_gs[1, 3], aspect='auto')
button_beta_dec = Button(button_beta_dec_ax, '-', color='#404040', hovercolor='#505050')
button_beta_dec.label.set_color('white')

button_beta_inc_ax = fig.add_subplot(sliders_gs[1, 4], aspect='auto')
button_beta_inc = Button(button_beta_inc_ax, '+', color='#404040', hovercolor='#505050')
button_beta_inc.label.set_color('white')

button_beta_ax = fig.add_subplot(sliders_gs[1, 5])
button_beta = Button(button_beta_ax, 'Start β', color='#404040', hovercolor='#505050')
button_beta.label.set_color('white')

ax_height = fig.add_subplot(sliders_gs[2, :2])
ax_height.set_facecolor('#505050')
slider_height = Slider(ax_height, 'Height (cm)  ', -cathode_radius * 1.5, cathode_radius * 1.5, valinit=initial_height, valstep=cathode_radius * 0.05, color='#ffffff')
slider_height.valtext.set_visible(False)

ax_height_text = fig.add_subplot(sliders_gs[2, 2])
ax_height_text.set_facecolor('#505050')
text_height = TextBox(ax_height_text, '', initial=str(initial_height), color='#404040', hovercolor='#505050')
text_height.label.set_color('white')
text_height.text_disp.set_color('white')

button_height_dec_ax = fig.add_subplot(sliders_gs[2, 3], aspect='auto')
button_height_dec = Button(button_height_dec_ax, '-', color='#404040', hovercolor='#505050')
button_height_dec.label.set_color('white')

button_height_inc_ax = fig.add_subplot(sliders_gs[2, 4], aspect='auto')
button_height_inc = Button(button_height_inc_ax, '+', color='#404040', hovercolor='#505050')
button_height_inc.label.set_color('white')

button_height_ax = fig.add_subplot(sliders_gs[2, 5])
button_height = Button(button_height_ax, 'Start Height', color='#404040', hovercolor='#505050')
button_height.label.set_color('white')

# Scale Coefficient Slider with Text Box and Buttons
ax_scale_coef = fig.add_subplot(sliders_gs[3, :2])
ax_scale_coef.set_facecolor('#505050')
slider_scale_coef = Slider(
    ax_scale_coef, 'Scale Coefficient  ', 0.05, 1.0,
    valinit=0.35, valstep=0.05, color='#ffffff'
)
slider_scale_coef.valtext.set_visible(False)

# Scale Coefficient Text Box
ax_scale_coef_text = fig.add_subplot(sliders_gs[3, 2])
ax_scale_coef_text.set_facecolor('#505050')
text_scale_coef = TextBox(
    ax_scale_coef_text, '', initial=f"{slider_scale_coef.val:.2f}",
    color='#404040', hovercolor='#505050'
)
text_scale_coef.label.set_color('white')
text_scale_coef.text_disp.set_color('white')

# Scale Coefficient Decrement Button
button_scale_coef_dec_ax = fig.add_subplot(sliders_gs[3, 3], aspect='auto')
button_scale_coef_dec = Button(
    button_scale_coef_dec_ax, '-', color='#404040', hovercolor='#505050'
)
button_scale_coef_dec.label.set_color('white')

# Scale Coefficient Increment Button
button_scale_coef_inc_ax = fig.add_subplot(sliders_gs[3, 4], aspect='auto')
button_scale_coef_inc = Button(
    button_scale_coef_inc_ax, '+', color='#404040', hovercolor='#505050'
)
button_scale_coef_inc.label.set_color('white')


# Update functions for Scale Coefficient
def update_scale_coef(val):
    text_scale_coef.set_val(f"{slider_scale_coef.val:.2f}")
    update_plot(val)


def submit_scale_coef(text):
    try:
        value = float(text)
        if slider_scale_coef.valmin <= value <= slider_scale_coef.valmax:
            slider_scale_coef.set_val(value)
        else:
            print(f"Scale coefficient must be between {slider_scale_coef.valmin} and {slider_scale_coef.valmax}")
    except ValueError:
        print("Invalid input for scale coefficient")


slider_scale_coef.on_changed(update_scale_coef)
text_scale_coef.on_submit(submit_scale_coef)


# Increment and Decrement Button Functions for Scale Coefficient
def decrement_scale_coef(event):
    new_val = slider_scale_coef.val - slider_scale_coef.valstep
    if new_val >= slider_scale_coef.valmin:
        slider_scale_coef.set_val(new_val)
    else:
        slider_scale_coef.set_val(slider_scale_coef.valmin)
    text_scale_coef.set_val(f"{slider_scale_coef.val:.2f}")


def increment_scale_coef(event):
    new_val = slider_scale_coef.val + slider_scale_coef.valstep
    if new_val <= slider_scale_coef.valmax:
        slider_scale_coef.set_val(new_val)
    else:
        slider_scale_coef.set_val(slider_scale_coef.valmax)
    text_scale_coef.set_val(f"{slider_scale_coef.val:.2f}")


button_scale_coef_dec.on_clicked(decrement_scale_coef)
button_scale_coef_inc.on_clicked(increment_scale_coef)

ax_3d = fig.add_subplot(control_gs[7, 0], projection='3d')
ax_3d.set_facecolor('#303030')
ax_3d.grid(False)
ax_3d.set_xlim(-view_radius, view_radius)
ax_3d.set_ylim(-view_radius, view_radius)
ax_3d.set_zlim(-view_radius, view_radius)
ax_3d.set_xlabel('X')
ax_3d.set_ylabel('Y')
ax_3d.set_zlabel('Z')
ax_3d.set_title('Current Cross-Section', color='white', fontsize=12)
ax_3d.set_xticklabels([])
ax_3d.set_yticklabels([])
ax_3d.set_zticklabels([])

current_plane = None

try:
    ax_3d.set_box_aspect([1, 1, 1])
except AttributeError:
    set_axes_equal(ax_3d)

# ---------------------------
# Animation Setup
# ---------------------------

anim_alpha = False
anim_beta = False
anim_height = False
timer = fig.canvas.new_timer(interval=timer_interval)


def animate():
    global anim_alpha, anim_beta, anim_height
    updated = False
    current_alpha = slider_alpha.val
    current_beta = slider_beta.val
    current_height = slider_height.val
    new_alpha = current_alpha
    new_beta = current_beta
    new_height = current_height
    if anim_alpha:
        new_alpha += alpha_step
        if new_alpha > 360:
            new_alpha -= 360
        slider_alpha.set_val(new_alpha)
        text_alpha.set_val(f"{new_alpha:.2f}")
        updated = True
    if anim_beta:
        new_beta += beta_step
        if new_beta > 180:
            new_beta -= 180
        slider_beta.set_val(new_beta)
        text_beta.set_val(f"{new_beta:.2f}")
        updated = True
    if anim_height:
        new_height += height_step
        if new_height > cathode_radius * 1.5:
            new_height = -cathode_radius * 1.5
        slider_height.set_val(new_height)
        text_height.set_val(f"{new_height:.2f}")
        updated = True
    if updated:
        fig.canvas.draw_idle()


timer.add_callback(animate)
timer.start()


def toggle_animate_alpha(event):
    global anim_alpha
    anim_alpha = not anim_alpha
    if anim_alpha:
        button_alpha.label.set_text('Stop α')
    else:
        button_alpha.label.set_text('Start α')


def toggle_animate_beta(event):
    global anim_beta
    anim_beta = not anim_beta
    if anim_beta:
        button_beta.label.set_text('Stop β')
    else:
        button_beta.label.set_text('Start β')


def toggle_animate_height(event):
    global anim_height
    anim_height = not anim_height
    if anim_height:
        button_height.label.set_text('Stop Height')
    else:
        button_height.label.set_text('Start Height')


button_alpha.on_clicked(toggle_animate_alpha)
button_beta.on_clicked(toggle_animate_beta)
button_height.on_clicked(toggle_animate_height)

# ---------------------------
# Load Previous Computation Functionality
# ---------------------------


def load_previous_computation(event):
    global grid_size
    global V, Ex, Ey, Ez, E_magnitude, E_magnitude_norm
    global x, y, z, X, Y, Z
    global rings, max_grid_spacing
    global update_plot, loading_data, cathode_radio, cathode_radio_cid
    global cathode_radius, anode_radius, computation_radius, view_radius, grid_size, V0
    global num_rings
    global iteration_count_global, final_delta_global, computation_time_global

    loading_data = True
    root = tk.Tk()
    root.withdraw()
    selected_dir = filedialog.askdirectory(title='Select Computation Directory')
    if not selected_dir:
        print("No directory selected.")
        loading_data = False
        return
    print(f"Loading data from {selected_dir}")
    try:
        # Define file paths
        Ex_file = os.path.join(selected_dir, 'Ex.npy')
        Ey_file = os.path.join(selected_dir, 'Ey.npy')
        Ez_file = os.path.join(selected_dir, 'Ez.npy')
        E_magnitude_file = os.path.join(selected_dir, 'E_magnitude.npy')
        V_file = os.path.join(selected_dir, 'V.npy')
        x_file = os.path.join(selected_dir, 'x.npy')
        y_file = os.path.join(selected_dir, 'y.npy')
        z_file = os.path.join(selected_dir, 'z.npy')

        # Check if .npy files exist
        if os.path.exists(Ex_file):
            # Load data from .npy files
            Ex = np.load(Ex_file)
            Ey = np.load(Ey_file)
            Ez = np.load(Ez_file)
            E_magnitude = np.load(E_magnitude_file)
            V = np.load(V_file)
            x = np.load(x_file)
            y = np.load(y_file)
            z = np.load(z_file)
        else:
            # Check if CSV files exist
            Ex_csv_file = os.path.join(selected_dir, 'Ex.csv')
            if os.path.exists(Ex_csv_file):
                print("Converting CSV files to .npy files...")
                # Load from CSV files
                Ex_flat = np.loadtxt(Ex_csv_file, delimiter=',')
                Ey_flat = np.loadtxt(os.path.join(selected_dir, 'Ey.csv'), delimiter=',')
                Ez_flat = np.loadtxt(os.path.join(selected_dir, 'Ez.csv'), delimiter=',')
                E_magnitude_flat = np.loadtxt(os.path.join(selected_dir, 'E_magnitude.csv'), delimiter=',')
                V_flat = np.loadtxt(os.path.join(selected_dir, 'V.csv'), delimiter=',')
                x = np.loadtxt(os.path.join(selected_dir, 'x.csv'), delimiter=',')
                y = np.loadtxt(os.path.join(selected_dir, 'y.csv'), delimiter=',')
                z = np.loadtxt(os.path.join(selected_dir, 'z.csv'), delimiter=',')

                # Infer grid size
                grid_size = x.size

                # Reshape data
                Ex = Ex_flat.reshape((grid_size, grid_size, grid_size))
                Ey = Ey_flat.reshape((grid_size, grid_size, grid_size))
                Ez = Ez_flat.reshape((grid_size, grid_size, grid_size))
                E_magnitude = E_magnitude_flat.reshape((grid_size, grid_size, grid_size))
                V = V_flat.reshape((grid_size, grid_size, grid_size))

                # Save as .npy files for future use
                np.save(Ex_file, Ex)
                np.save(Ey_file, Ey)
                np.save(Ez_file, Ez)
                np.save(E_magnitude_file, E_magnitude)
                np.save(V_file, V)
                np.save(x_file, x)
                np.save(y_file, y)
                np.save(z_file, z)

                # Optionally, delete CSV files to save space
                os.remove(Ex_csv_file)
                os.remove(os.path.join(selected_dir, 'Ey.csv'))
                os.remove(os.path.join(selected_dir, 'Ez.csv'))
                os.remove(os.path.join(selected_dir, 'E_magnitude.csv'))
                os.remove(os.path.join(selected_dir, 'V.csv'))
                os.remove(os.path.join(selected_dir, 'x.csv'))
                os.remove(os.path.join(selected_dir, 'y.csv'))
                os.remove(os.path.join(selected_dir, 'z.csv'))
            else:
                print("No data files found in the selected directory.")
                loading_data = False
                return

        # Use NumPy functions since data is in NumPy arrays
        X, Y, Z = np.meshgrid(x, y, z, indexing='ij')
        E_magnitude_norm = scale_E_field(E_magnitude, 'Linear')

        dx = x[1] - x[0]
        dy = y[1] - y[0]
        dz = z[1] - z[0]
        max_grid_spacing = np.sqrt(dx ** 2 + dy ** 2 + dz ** 2)

        # Read summary to get parameters
        summary_file = os.path.join(selected_dir, 'computation_summary.txt')
        if os.path.exists(summary_file):
            with open(summary_file, 'r') as f:
                summary = f.read()
            print(summary)
            # Extract parameters from summary
            params = {}
            for line in summary.split('\n'):
                if ':' in line:
                    key, value = line.split(':', 1)
                    params[key.strip()] = value.strip()
            # Update variables
            if 'Cathode Radius' in params:
                cathode_radius = float(params['Cathode Radius'].split()[0])
            if 'Anode Radius' in params:
                anode_radius = float(params['Anode Radius'].split()[0])
            if 'Potential Difference (V0)' in params:
                V0 = float(params['Potential Difference (V0)'].split()[0])
            computation_radius = cathode_radius * 2
            view_radius = cathode_radius * 1.5
            if 'Number of Rings' in params:
                num_rings = int(params['Number of Rings'])
            else:
                num_rings = 13

            # Update global variables for saving
            if 'Iteration Count' in params:
                iteration_count_global = int(params['Iteration Count'])
            else:
                iteration_count_global = None
            if 'Final Delta' in params:
                final_delta_global = float(params['Final Delta'])
            else:
                final_delta_global = None
            if 'Computation Time' in params:
                # Extract computation time
                computation_time_str = params['Computation Time']
                computation_time_global = float(computation_time_str.split()[0])
            else:
                computation_time_global = None
        else:
            # If summary file doesn't exist, set defaults or infer from folder name
            folder_name = os.path.basename(selected_dir)
            if '1_ring' in folder_name:
                num_rings = 1
            elif '2_rings' in folder_name:
                num_rings = 2
            elif '3_rings' in folder_name:
                num_rings = 3
            elif '13_rings' in folder_name:
                num_rings = 13
            else:
                num_rings = 13  # Default to 13 rings
            # Set default values
            cathode_radius = 4.572  # Default value or adjust as needed
            anode_radius = 22.86  # Default value or adjust as needed
            computation_radius = cathode_radius * 2
            view_radius = cathode_radius * 1.5
            # Set computation parameters to None
            iteration_count_global = None
            final_delta_global = None
            computation_time_global = None

        # Generate rings with updated cathode_radius
        rings = generate_cathode_rings(cathode_radius, num_rings)

        # Update cathode configuration in GUI without triggering update_plot
        cathode_options = cathode_radio.labels
        for i, label in enumerate(cathode_options):
            if label.get_text() == f'{num_rings} Ring' + ('s' if num_rings > 1 else ''):
                # Temporarily disconnect update_plot callback
                if cathode_radio_cid is not None:
                    cathode_radio.disconnect(cathode_radio_cid)
                cathode_radio.set_active(i)
                # Reconnect update_plot callback
                cathode_radio_cid = cathode_radio.on_clicked(update_plot)
                update_plot.cathode_config = num_rings
                break
        else:
            update_plot.cathode_config = num_rings

        # Update plot axes limits and extents
        cross_section_radius = cathode_radius * 2
        ax_2d.set_xlim(-cross_section_radius, cross_section_radius)
        ax_2d.set_ylim(-cross_section_radius, cross_section_radius)
        im.set_extent((-cross_section_radius, cross_section_radius, -cross_section_radius, cross_section_radius))
        ax_3d.set_xlim(-view_radius, view_radius)
        ax_3d.set_ylim(-view_radius, view_radius)
        ax_3d.set_zlim(-view_radius, view_radius)

        # Update slider ranges based on new cathode radius
        slider_height.valmin = -cathode_radius * 1.5
        slider_height.valmax = cathode_radius * 1.5
        slider_height.ax.set_xlim(slider_height.valmin, slider_height.valmax)

        loading_data = False
        # Update plots
        update_plot(None)
    except Exception as e:
        print(f"Error loading data: {e}")
        loading_data = False


load_button.on_clicked(load_previous_computation)

# ---------------------------
# Save Current Computation Functionality
# ---------------------------


def save_current_computation(event):
    global Ex, Ey, Ez, E_magnitude, V, x, y, z
    global cathode_radius, anode_radius, V0, grid_size, num_rings
    global iteration_count_global, final_delta_global, computation_time_global

    # Check if the computation has been performed
    if V is None:
        print("No computation data to save.")
        return

    # Create unique output directory
    timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')
    output_dir_name = f'Cathode_{num_rings}_rings_{timestamp}'
    output_dir = os.path.join('electric_field_data', output_dir_name)
    os.makedirs(output_dir, exist_ok=True)

    # Save data to NumPy .npy files
    np.save(os.path.join(output_dir, 'Ex.npy'), cp.asnumpy(Ex))
    np.save(os.path.join(output_dir, 'Ey.npy'), cp.asnumpy(Ey))
    np.save(os.path.join(output_dir, 'Ez.npy'), cp.asnumpy(Ez))
    np.save(os.path.join(output_dir, 'E_magnitude.npy'), cp.asnumpy(E_magnitude))
    np.save(os.path.join(output_dir, 'V.npy'), cp.asnumpy(V))
    np.save(os.path.join(output_dir, 'x.npy'), cp.asnumpy(x))
    np.save(os.path.join(output_dir, 'y.npy'), cp.asnumpy(y))
    np.save(os.path.join(output_dir, 'z.npy'), cp.asnumpy(z))

    # Generate summary text file
    with open(os.path.join(output_dir, 'computation_summary.txt'), 'w') as f:
        f.write("Electric Field Computation Summary\n")
        f.write("--------------------------------\n")
        f.write(f"Cathode Radius: {cathode_radius} cm\n")
        f.write(f"Anode Radius: {anode_radius} cm\n")
        f.write(f"Potential Difference (V0): {V0} V\n")
        f.write(f"Grid Size: {grid_size} x {grid_size} x {grid_size}\n")
        f.write(f"Number of Rings: {num_rings}\n")
        f.write(f"Iteration Count: {iteration_count_global}\n")
        f.write(f"Final Delta: {final_delta_global}\n")
        f.write(f"Computation Time: {computation_time_global} seconds\n")
        f.write("Data saved in NumPy .npy format in this directory.\n")

    print(f"Computation data saved in {output_dir}")


save_button.on_clicked(save_current_computation)

# ---------------------------
# Toggle Field Lines Functionality
# ---------------------------


def toggle_field_lines(event):
    global field_lines_visible, field_line_artist
    field_lines_visible = not field_lines_visible
    if field_lines_visible:
        fieldline_button.label.set_text('Hide Field Lines')
    else:
        fieldline_button.label.set_text('Show Field Lines')
        # Hide existing field lines if they exist
        if field_line_artist is not None:
            field_line_artist.lines.remove()
            field_line_artist = None
    update_plot(None)


fieldline_button.on_clicked(toggle_field_lines)

# ---------------------------
# Update Function
# ---------------------------


def update_plot(val, alpha=None, beta=None, height=None):
    global computation_in_progress
    global field_line_density
    field_line_density = slider_field_density.val
    global grid_size
    global im, scaling_method, interpolation_radio, slider_scale_coef, ax_3d
    global V, Ex, Ey, Ez, E_magnitude, E_magnitude_norm, rings, X, Y, Z, current_plane
    global max_grid_spacing, loading_data
    global computation_radius, view_radius, cathode_radius
    global x, y, z
    global iteration_count_global, final_delta_global, computation_time_global, num_rings, V0
    global field_lines_visible, field_line_artist, field_line_arrow_patches

    if loading_data:
        return  # Do not update plot during data loading

    if computation_in_progress:
        return  # Do not start a new computation while one is in progress

    # Get user inputs
    alpha = slider_alpha.val
    beta = slider_beta.val
    height = slider_height.val
    interpolation = interpolation_radio.value_selected.lower()
    scale_coef = slider_scale_coef.val
    cathode_selection = cathode_radio.value_selected

    # Use provided alpha, beta, height or default to slider values
    if alpha is None:
        alpha = slider_alpha.val
    if beta is None:
        beta = slider_beta.val
    if height is None:
        height = slider_height.val

    # Determine the number of rings based on the selection
    if cathode_selection == '1 Ring':
        num_rings = 1
    elif cathode_selection == '2 Rings':
        num_rings = 2
    elif cathode_selection == '3 Rings':
        num_rings = 3
    elif cathode_selection == '13 Rings':
        num_rings = 13
    else:
        # No valid cathode configuration selected yet
        fig.canvas.draw_idle()
        return

    if update_plot.cathode_config != num_rings or V is None:
        # Start the computation in a separate thread
        computation_in_progress = True
        disable_ui_elements()
        computation_thread = threading.Thread(target=compute_potential_thread)
        computation_thread.start()
        # Return immediately to keep UI responsive
        return

    # Update 3D plot
    if V is not None:
        ax_3d.cla()
        ax_3d.set_facecolor('#303030')
        ax_3d.grid(False)
        ax_3d.set_xlim(-view_radius, view_radius)
        ax_3d.set_ylim(-view_radius, view_radius)
        ax_3d.set_zlim(-view_radius, view_radius)
        ax_3d.set_xlabel('X')
        ax_3d.set_ylabel('Y')
        ax_3d.set_zlabel('Z')
        ax_3d.set_title('Current Cross-Section', color='white', fontsize=12)
        # Remove axis tick labels
        ax_3d.set_xticklabels([])
        ax_3d.set_yticklabels([])
        ax_3d.set_zticklabels([])
        # Plot rings
        for ring in rings:
            x_ring, y_ring, z_ring, n = ring
            x_ring_cpu = cp.asnumpy(x_ring)
            y_ring_cpu = cp.asnumpy(y_ring)
            z_ring_cpu = cp.asnumpy(z_ring)
            ax_3d.plot(x_ring_cpu, y_ring_cpu, z_ring_cpu, color='cyan', linewidth=1)
        current_plane = None
        plot_cross_section_plane(ax_3d, alpha, beta, height)
        try:
            ax_3d.set_box_aspect([1, 1, 1])
        except AttributeError:
            set_axes_equal(ax_3d)
    # Update 2D plot axes limits with updated cathode_radius
    cross_section_radius = cathode_radius * 2
    ax_2d.set_xlim(-cross_section_radius, cross_section_radius)
    ax_2d.set_ylim(-cross_section_radius, cross_section_radius)
    im.set_extent((-cross_section_radius, cross_section_radius, -cross_section_radius, cross_section_radius))
    # Ensure that arrays are NumPy arrays
    if isinstance(E_magnitude_norm, cp.ndarray):
        E_magnitude_norm = cp.asnumpy(E_magnitude_norm)
    if isinstance(X, cp.ndarray):
        X = cp.asnumpy(X)
        Y = cp.asnumpy(Y)
        Z = cp.asnumpy(Z)
    if isinstance(Ex, cp.ndarray):
        Ex = cp.asnumpy(Ex)
        Ey = cp.asnumpy(Ey)
        Ez = cp.asnumpy(Ez)
    if isinstance(x, cp.ndarray):
        x = cp.asnumpy(x)
        y = cp.asnumpy(y)
        z = cp.asnumpy(z)
    # Get the slice data, including field components
    u_new, v_new, E_plane_new, E_u, E_v = get_slice(
        E_magnitude_norm, X, Y, Z, alpha, beta, height, max_grid_spacing, Ex, Ey, Ez, x, y, z
    )
    if len(u_new) == 0 or len(v_new) == 0:
        print("No data points found for the selected slice.")
        im.set_data(np.zeros_like(im.get_array()))
        ax_2d.set_title(f'No data for α={alpha:.1f}°, β={beta:.1f}°, Height={height:.2f} cm')
        fig.canvas.draw_idle()
        return
    try:
        # Use the image array's shape to determine the number of grid points
        num_grid_points = im.get_array().shape[0]
        ui_fixed = np.linspace(-cross_section_radius, cross_section_radius, num_grid_points)
        vi_fixed = np.linspace(-cross_section_radius, cross_section_radius, num_grid_points)
        ui_grid_fixed, vi_grid_fixed = np.meshgrid(ui_fixed, vi_fixed)

        # Interpolate onto the new grid
        Ei = griddata((u_new, v_new), E_plane_new, (ui_grid_fixed, vi_grid_fixed), method=interpolation)
        Ei = np.nan_to_num(Ei, nan=0.0)
        # Apply Gaussian blur to the image data
        blur_amount = slider_gaussian_blur.val  # Value between 0 and 1
        if blur_amount > 0:
            max_sigma = 5  # Adjust this value as needed for maximum blur
            sigma = blur_amount * max_sigma
            Ei_blurred = gaussian_filter(Ei, sigma=sigma)
        else:
            Ei_blurred = Ei
        im.set_data(Ei_blurred.T)
        # Interpolate field components onto the grid for field lines
        E_u_interp = griddata((u_new, v_new), E_u, (ui_grid_fixed, vi_grid_fixed), method=interpolation)
        E_v_interp = griddata((u_new, v_new), E_v, (ui_grid_fixed, vi_grid_fixed), method=interpolation)
        E_u_interp = np.nan_to_num(E_u_interp, nan=0.0)
        E_v_interp = np.nan_to_num(E_v_interp, nan=0.0)
        # Store for field lines
        update_plot.ui_fixed = ui_fixed
        update_plot.vi_fixed = vi_fixed
        update_plot.E_u_interp = E_u_interp
        update_plot.E_v_interp = E_v_interp
    except Exception as e:
        print(f"Interpolation error: {e}")
        Ei = np.zeros_like(im.get_array())
        im.set_data(Ei.T)
    im.set_norm(colors.PowerNorm(gamma=scale_coef))
    im.changed()
    ax_2d.set_title(f'Cross-Section at α={alpha:.1f}°, β={beta:.1f}°, Height={height:.2f} cm', fontsize=12)

    # Plot field lines if visible
    if field_lines_visible:
        # Remove existing field lines if they exist
        if field_line_artist is not None:
            field_line_artist.lines.remove()
            field_line_artist = None

        arrowsize_value = 1

        # Plot new field lines with transposed field components
        field_line_artist = ax_2d.streamplot(
            update_plot.ui_fixed, update_plot.vi_fixed,
            update_plot.E_u_interp.T, update_plot.E_v_interp.T,
            color='white', linewidth=field_line_width,
            density=field_line_density,
            arrowsize=arrowsize_value
        )
        # Remove arrowheads if not desired
        for art in ax_2d.get_children():
            if isinstance(art, patches.FancyArrowPatch):
                art.remove()
    else:
        if field_line_artist is not None:
            # Remove the field lines
            field_line_artist.lines.remove()
            field_line_artist = None

        # Update simulation summary information
    if iteration_count_global is not None and final_delta_global is not None and computation_time_global is not None:
        attributes = [
            ('Cathode Configuration:', f'{num_rings} Ring{"s" if num_rings > 1 else ""}'),
            ('Cathode Radius:', f'{cathode_radius:.2f} cm'),
            ('Anode Radius:', f'{anode_radius:.2f} cm'),
            ('Cathode Voltage:', f'{V0:.1f} V'),
            ('Computation Grid Size:', f'{grid_size} x {grid_size} x {grid_size}'),
            ('Iteration Count:', f'{iteration_count_global}'),
            ('Final Delta:', f'{final_delta_global:.4e}'),
            ('Computation Time:', f'{computation_time_global:.2f} s'),
        ]

        # Construct summary_str
        line_format = '{:<25} {:<15}'
        summary_lines = [line_format.format(attr, value) for attr, value in attributes]
        summary_str = '\n'.join(summary_lines)

        summary_text.set_text(summary_str)
        summary_text.set_fontfamily('monospace')
    else:
        summary_str = "Simulation not yet performed."
        summary_text.set_text(summary_str)
        summary_text.set_fontfamily('monospace')
    fig.canvas.draw_idle()


def compute_potential_thread():
    global V, Ex, Ey, Ez, E_magnitude, E_magnitude_norm
    global iteration_count_global, final_delta_global, computation_time_global
    global max_grid_spacing, computation_in_progress
    global x, y, z
    global rings

    # Update status message
    update_status_message("Computation in progress...")

    try:
        # Generate grid
        x = cp.linspace(-computation_radius, computation_radius, grid_size)
        y = cp.linspace(-computation_radius, computation_radius, grid_size)
        z = cp.linspace(-computation_radius, computation_radius, grid_size)

        dx = cp.abs(x[1] - x[0])
        dy = cp.abs(y[1] - y[0])
        dz = cp.abs(z[1] - z[0])
        max_grid_spacing = float(cp.sqrt(dx ** 2 + dy ** 2 + dz ** 2).get())

        # Generate rings
        rings = generate_cathode_rings(cathode_radius, num_rings)

        # Perform computation
        V = cp.zeros((grid_size, grid_size, grid_size), dtype=cp.float32)
        V = apply_boundary_conditions(V, rings, V0, x, y, z)
        V_cpu, iteration_count, final_delta, computation_time = solve_potential(V, rings, V0, x, y, z)

        # Store computation results globally
        iteration_count_global = iteration_count
        final_delta_global = final_delta
        computation_time_global = computation_time

        # Transfer V back to GPU for gradient computation
        V = cp.asarray(V_cpu)
        Ex, Ey, Ez = cp.gradient(-V, x, y, z, edge_order=2)
        E_magnitude = cp.sqrt(Ex ** 2 + Ey ** 2 + Ez ** 2)
        E_magnitude_norm = scale_E_field(E_magnitude, 'Linear')
        fig.canvas.manager.window.after(0, on_computation_done)

    except Exception as e:
        print(f"Error during computation: {e}")
    finally:
        computation_in_progress = False
        # Schedule the plot update in the main thread
        fig.canvas.manager.window.after(0, on_computation_done)


def on_computation_done():
    # Re-enable UI elements
    enable_ui_elements()

    # Proceed to update the plots with the new data
    update_plot_after_computation()


def update_plot_after_computation():
    global field_line_density
    global im, scaling_method, interpolation_radio, slider_scale_coef, ax_3d
    global V, Ex, Ey, Ez, E_magnitude, E_magnitude_norm, rings, X, Y, Z, current_plane
    global max_grid_spacing, loading_data
    global computation_radius, view_radius, cathode_radius
    global x, y, z
    global iteration_count_global, final_delta_global, computation_time_global, num_rings, V0
    global field_lines_visible, field_line_artist, field_line_arrow_patches
    global update_plot

    # Re-enable UI elements
    enable_ui_elements()

    # Retrieve the latest slider and UI values
    alpha = slider_alpha.val
    beta = slider_beta.val
    height = slider_height.val
    interpolation = interpolation_radio.value_selected.lower()
    scale_coef = slider_scale_coef.val

    # Update 3D plot
    if V is not None:
        # Convert x, y, z to NumPy arrays if they are CuPy arrays
        if isinstance(x, cp.ndarray):
            x_cpu = cp.asnumpy(x)
            y_cpu = cp.asnumpy(y)
            z_cpu = cp.asnumpy(z)
        else:
            x_cpu = x
            y_cpu = y
            z_cpu = z

        grid_size = len(x_cpu)

        # Transfer data to CPU for plotting
        Ex_cpu = cp.asnumpy(Ex)
        Ey_cpu = cp.asnumpy(Ey)
        Ez_cpu = cp.asnumpy(Ez)
        E_magnitude_cpu = cp.asnumpy(E_magnitude)
        E_magnitude_norm_cpu = cp.asnumpy(E_magnitude_norm)
        X_cpu, Y_cpu, Z_cpu = np.meshgrid(x_cpu, y_cpu, z_cpu, indexing='ij')

        x = x_cpu
        y = y_cpu
        z = z_cpu
        Ex = Ex_cpu
        Ey = Ey_cpu
        Ez = Ez_cpu
        E_magnitude = E_magnitude_cpu
        E_magnitude_norm = E_magnitude_norm_cpu
        X = X_cpu
        Y = Y_cpu
        Z = Z_cpu

        # Update 3D plot
        ax_3d.cla()
        ax_3d.set_facecolor('#303030')
        ax_3d.grid(False)
        ax_3d.set_xlim(-view_radius, view_radius)
        ax_3d.set_ylim(-view_radius, view_radius)
        ax_3d.set_zlim(-view_radius, view_radius)
        ax_3d.set_xlabel('X')
        ax_3d.set_ylabel('Y')
        ax_3d.set_zlabel('Z')
        ax_3d.set_title('Current Cross-Section', color='white', fontsize=12)
        # Remove axis tick labels
        ax_3d.set_xticklabels([])
        ax_3d.set_yticklabels([])
        ax_3d.set_zticklabels([])

        # Plot rings
        for ring in rings:
            x_ring, y_ring, z_ring, n = ring
            ax_3d.plot(x_ring, y_ring, z_ring, color='cyan', linewidth=1)

        current_plane = None
        plot_cross_section_plane(ax_3d, alpha, beta, height)

        try:
            ax_3d.set_box_aspect([1, 1, 1])
        except AttributeError:
            set_axes_equal(ax_3d)

    # Update 2D plot axes limits with updated cathode_radius
    cross_section_radius = cathode_radius * 2
    ax_2d.set_xlim(-cross_section_radius, cross_section_radius)
    ax_2d.set_ylim(-cross_section_radius, cross_section_radius)
    im.set_extent((-cross_section_radius, cross_section_radius, -cross_section_radius, cross_section_radius))

    # Get the slice data, including field components
    u_new, v_new, E_plane_new, E_u, E_v = get_slice(
        E_magnitude_norm, X, Y, Z, alpha, beta, height, max_grid_spacing, Ex, Ey, Ez, x, y, z
    )

    if len(u_new) == 0 or len(v_new) == 0:
        print("No data points found for the selected slice.")
        im.set_data(np.zeros_like(im.get_array()))
        ax_2d.set_title(f'No data for α={alpha:.1f}°, β={beta:.1f}°, Height={height:.2f} cm')
        fig.canvas.draw_idle()
        return

    try:
        # Use the image array's shape to determine the number of grid points
        num_grid_points = im.get_array().shape[0]
        ui_fixed = np.linspace(-cross_section_radius, cross_section_radius, num_grid_points)
        vi_fixed = np.linspace(-cross_section_radius, cross_section_radius, num_grid_points)
        ui_grid_fixed, vi_grid_fixed = np.meshgrid(ui_fixed, vi_fixed)

        # Interpolate onto the new grid
        Ei = griddata((u_new, v_new), E_plane_new, (ui_grid_fixed, vi_grid_fixed), method=interpolation)
        Ei = np.nan_to_num(Ei, nan=0.0)
        im.set_data(Ei.T)

        # Interpolate field components onto the grid for field lines
        E_u_interp = griddata((u_new, v_new), E_u, (ui_grid_fixed, vi_grid_fixed), method=interpolation)
        E_v_interp = griddata((u_new, v_new), E_v, (ui_grid_fixed, vi_grid_fixed), method=interpolation)
        E_u_interp = np.nan_to_num(E_u_interp, nan=0.0)
        E_v_interp = np.nan_to_num(E_v_interp, nan=0.0)

        # Store for field lines
        update_plot_after_computation.ui_fixed = ui_fixed
        update_plot_after_computation.vi_fixed = vi_fixed
        update_plot_after_computation.E_u_interp = E_u_interp
        update_plot_after_computation.E_v_interp = E_v_interp

    except Exception as e:
        print(f"Interpolation error: {e}")
        Ei = np.zeros_like(im.get_array())
        im.set_data(Ei.T)

    im.set_norm(colors.PowerNorm(gamma=scale_coef))
    im.changed()
    ax_2d.set_title(f'Cross-Section at α={alpha:.1f}°, β={beta:.1f}°, Height={height:.2f} cm', fontsize=12)

    # Plot field lines if visible
    if field_lines_visible:
        # Remove existing field lines if they exist
        if field_line_artist is not None:
            field_line_artist.lines.remove()
            field_line_artist = None

        arrowsize_value = 1

        # Plot new field lines with transposed field components
        field_line_artist = ax_2d.streamplot(
            update_plot_after_computation.ui_fixed, update_plot_after_computation.vi_fixed,
            update_plot_after_computation.E_u_interp.T, update_plot_after_computation.E_v_interp.T,
            color='white', linewidth=field_line_width,
            density=field_line_density,
            arrowsize=arrowsize_value
        )
        # Remove arrowheads if not desired
        for art in ax_2d.get_children():
            if isinstance(art, patches.FancyArrowPatch):
                art.remove()
    else:
        if field_line_artist is not None:
            # Remove the field lines
            field_line_artist.lines.remove()
            field_line_artist = None

    # Update simulation summary information
    if iteration_count_global is not None and final_delta_global is not None and computation_time_global is not None:
        attributes = [
            ('Cathode Configuration:', f'{num_rings} Ring{"s" if num_rings > 1 else ""}'),
            ('Cathode Radius:', f'{cathode_radius:.2f} cm'),
            ('Anode Radius:', f'{anode_radius:.2f} cm'),
            ('Cathode Voltage:', f'{V0:.1f} V'),
            ('Computation Grid Size:', f'{grid_size} x {grid_size} x {grid_size}'),
            ('Iteration Count:', f'{iteration_count_global}'),
            ('Final Delta:', f'{final_delta_global:.4e}'),
            ('Computation Time:', f'{computation_time_global:.2f} s'),
        ]

        # Now, construct summary_str
        line_format = '{:<25} {:<15}'
        summary_lines = [line_format.format(attr, value) for attr, value in attributes]
        summary_str = '\n'.join(summary_lines)

        summary_text.set_text(summary_str)
        summary_text.set_fontfamily('monospace')
    else:
        summary_str = "Simulation not yet performed."
        summary_text.set_text(summary_str)
        summary_text.set_fontfamily('monospace')

    # Redraw the figure
    fig.canvas.draw_idle()
    update_plot.cathode_config = num_rings


def disable_ui_elements():
    global cathode_radio_cid
    # Disable sliders
    slider_alpha.eventson = False
    slider_beta.eventson = False
    slider_height.eventson = False
    slider_scale_coef.eventson = False
    slider_field_density.eventson = False

    # Disable buttons
    for btn in [button_alpha_dec, button_alpha_inc, button_beta_dec, button_beta_inc,
                button_height_dec, button_height_inc, button_scale_coef_dec, button_scale_coef_inc,
                button_field_density_dec, button_field_density_inc,
                load_button, save_button, fieldline_button, gif_button]:
        btn.eventson = False

    # Disable radio buttons by disconnecting the callback
    if cathode_radio_cid is not None:
        cathode_radio.disconnect(cathode_radio_cid)
        cathode_radio_cid = None

    # Update status message
    update_status_message("Computation in progress...")


def enable_ui_elements():
    global cathode_radio_cid
    # Re-enable sliders
    slider_alpha.eventson = True
    slider_beta.eventson = True
    slider_height.eventson = True
    slider_scale_coef.eventson = True
    slider_field_density.eventson = True

    # Re-enable buttons
    for btn in [button_alpha_dec, button_alpha_inc, button_beta_dec, button_beta_inc,
                button_height_dec, button_height_inc, button_scale_coef_dec, button_scale_coef_inc,
                button_field_density_dec, button_field_density_inc,
                load_button, save_button, fieldline_button, gif_button]:
        btn.eventson = True

    # Re-enable radio buttons by reconnecting the callback
    if cathode_radio_cid is None:
        cathode_radio_cid = cathode_radio.on_clicked(update_plot)

    # Update status message
    update_status_message("Ready")

    # Redraw the figure to reflect UI changes
    fig.canvas.draw_idle()


def update_status_message(message):
    # Update the status message in the GUI
    summary_text.set_text(message)
    fig.canvas.draw_idle()


update_plot.cathode_config = None


# Update functions to synchronize sliders and text boxes
def update_alpha(val):
    text_alpha.set_val(f"{slider_alpha.val:.2f}")
    update_plot(val)


def update_beta(val):
    text_beta.set_val(f"{slider_beta.val:.2f}")
    update_plot(val)


def update_height(val):
    text_height.set_val(f"{slider_height.val:.2f}")
    update_plot(val)


slider_alpha.on_changed(update_alpha)
slider_beta.on_changed(update_beta)
slider_height.on_changed(update_height)

interpolation_radio.on_clicked(update_plot)
slider_scale_coef.on_changed(update_plot)
# Store the callback ID for cathode_radio
cathode_radio_cid = cathode_radio.on_clicked(update_plot)


# Functions for TextBoxes
def submit_alpha(text):
    try:
        value = float(text)
        if slider_alpha.valmin <= value <= slider_alpha.valmax:
            slider_alpha.set_val(value)
        else:
            print(f"Alpha value must be between {slider_alpha.valmin} and {slider_alpha.valmax}")
    except ValueError:
        print("Invalid input for alpha")


def submit_beta(text):
    try:
        value = float(text)
        if slider_beta.valmin <= value <= slider_beta.valmax:
            slider_beta.set_val(value)
        else:
            print(f"Beta value must be between {slider_beta.valmin} and {slider_beta.valmax}")
    except ValueError:
        print("Invalid input for beta")


def submit_height(text):
    try:
        value = float(text)
        if slider_height.valmin <= value <= slider_height.valmax:
            slider_height.set_val(value)
        else:
            print(f"Height value must be between {slider_height.valmin} and {slider_height.valmax}")
    except ValueError:
        print("Invalid input for height")


text_alpha.on_submit(submit_alpha)
text_beta.on_submit(submit_beta)
text_height.on_submit(submit_height)


# Increment and Decrement Button Functions
def decrement_alpha(event):
    new_val = slider_alpha.val - slider_alpha.valstep
    if new_val >= slider_alpha.valmin:
        slider_alpha.set_val(new_val)
    else:
        slider_alpha.set_val(slider_alpha.valmin)
    text_alpha.set_val(f"{slider_alpha.val:.2f}")


def increment_alpha(event):
    new_val = slider_alpha.val + slider_alpha.valstep
    if new_val <= slider_alpha.valmax:
        slider_alpha.set_val(new_val)
    else:
        slider_alpha.set_val(slider_alpha.valmax)
    text_alpha.set_val(f"{slider_alpha.val:.2f}")


def decrement_beta(event):
    new_val = slider_beta.val - slider_beta.valstep
    if new_val >= slider_beta.valmin:
        slider_beta.set_val(new_val)
    else:
        slider_beta.set_val(slider_beta.valmin)
    text_beta.set_val(f"{slider_beta.val:.2f}")


def increment_beta(event):
    new_val = slider_beta.val + slider_beta.valstep
    if new_val <= slider_beta.valmax:
        slider_beta.set_val(new_val)
    else:
        slider_beta.set_val(slider_beta.valmax)
    text_beta.set_val(f"{slider_beta.val:.2f}")


def decrement_height(event):
    new_val = slider_height.val - slider_height.valstep
    if new_val >= slider_height.valmin:
        slider_height.set_val(new_val)
    else:
        slider_height.set_val(slider_height.valmin)
    text_height.set_val(f"{slider_height.val:.2f}")


def increment_height(event):
    new_val = slider_height.val + slider_height.valstep
    if new_val <= slider_height.valmax:
        slider_height.set_val(new_val)
    else:
        slider_height.set_val(slider_height.valmax)
    text_height.set_val(f"{new_val:.2f}")


def update_gaussian_blur(val):
    text_gaussian_blur.set_val(f"{slider_gaussian_blur.val:.2f}")
    update_plot(val)


def submit_gaussian_blur(text):
    try:
        value = float(text)
        if slider_gaussian_blur.valmin <= value <= slider_gaussian_blur.valmax:
            slider_gaussian_blur.set_val(value)
        else:
            print(f"Gaussian blur value must be between {slider_gaussian_blur.valmin} and {slider_gaussian_blur.valmax}")
    except ValueError:
        print("Invalid input for Gaussian blur")


def decrement_gaussian_blur(event):
    new_val = slider_gaussian_blur.val - slider_gaussian_blur.valstep
    if new_val >= slider_gaussian_blur.valmin:
        slider_gaussian_blur.set_val(new_val)
    else:
        slider_gaussian_blur.set_val(slider_gaussian_blur.valmin)
    text_gaussian_blur.set_val(f"{slider_gaussian_blur.val:.2f}")


def increment_gaussian_blur(event):
    new_val = slider_gaussian_blur.val + slider_gaussian_blur.valstep
    if new_val <= slider_gaussian_blur.valmax:
        slider_gaussian_blur.set_val(new_val)
    else:
        slider_gaussian_blur.set_val(slider_gaussian_blur.valmax)
    text_gaussian_blur.set_val(f"{slider_gaussian_blur.val:.2f}")


button_alpha_dec.on_clicked(decrement_alpha)
button_alpha_inc.on_clicked(increment_alpha)
button_beta_dec.on_clicked(decrement_beta)
button_beta_inc.on_clicked(increment_beta)
button_height_dec.on_clicked(decrement_height)
button_height_inc.on_clicked(increment_height)
slider_gaussian_blur.on_changed(update_gaussian_blur)
text_gaussian_blur.on_submit(submit_gaussian_blur)
button_gaussian_blur_dec.on_clicked(decrement_gaussian_blur)
button_gaussian_blur_inc.on_clicked(increment_gaussian_blur)

plt.show()
